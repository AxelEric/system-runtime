<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/metamodel.js - system-runtime</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
            system-runtime
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.9.9</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/syrup", "classes/syrup-behavior", "classes/syrup-component", "classes/syrup-db", "classes/syrup-helper", "classes/syrup-log", "classes/syrup-metamodel", "classes/syrup-state", "classes/syrup-system", "classes/syrup-workflow", "classes/SyrupDatabaseCollection", "classes/SyrupError", "modules/syrup", "modules/syrup-behavior", "modules/syrup-component", "modules/syrup-db", "modules/syrup-helper", "modules/syrup-log", "modules/syrup-metamodel", "modules/syrup-state", "modules/syrup-system", "modules/syrup-workflow"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/syrup.html">syrup</a></li>
                <li><a href="../classes/syrup-behavior.html">syrup-behavior</a></li>
                <li><a href="../classes/syrup-component.html">syrup-component</a></li>
                <li><a href="../classes/syrup-db.html">syrup-db</a></li>
                <li><a href="../classes/syrup-helper.html">syrup-helper</a></li>
                <li><a href="../classes/syrup-log.html">syrup-log</a></li>
                <li><a href="../classes/syrup-metamodel.html">syrup-metamodel</a></li>
                <li><a href="../classes/syrup-state.html">syrup-state</a></li>
                <li><a href="../classes/syrup-system.html">syrup-system</a></li>
                <li><a href="../classes/syrup-workflow.html">syrup-workflow</a></li>
                <li><a href="../classes/SyrupDatabaseCollection.html">SyrupDatabaseCollection</a></li>
                <li><a href="../classes/SyrupError.html">SyrupError</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/metamodel.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/*
 * SyrupJS
 * The System Runtime Platform
 * https://syrupjs.github.io
 * @ecarriou
 *  
 * Copyright (c) 2016 Erwan Carriou
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE. 
 */

/**
 * This module manages syrup metamodel. &lt;br&gt;
 * syrup metamodel loads schemas and types, analyzes them and creates the component classes and related SyrupDatabaseCollections.
 * 
 * @module syrup
 * @submodule syrup-metamodel
 * @requires syrup-db
 * @requires syrup-log
 * @requires syrup-component
 * @requires syrup-workflow
 * @class syrup-metamodel
 * @static
 */

&#x27;use strict&#x27;;

var $db = require(&#x27;./db.js&#x27;);
var $log = require(&#x27;./log.js&#x27;);
var $component = require(&#x27;./component.js&#x27;);
var $workflow = require(&#x27;./workflow.js&#x27;);


/* Private properties */


var ID = &#x27;_id&#x27;,
    NAME = &#x27;_name&#x27;,
    INHERITS = &#x27;_inherit&#x27;,
    SCHEMA = &#x27;_schema&#x27;,
    CLASS = &#x27;_class&#x27;,
    CORE = &#x27;_core&#x27;,
    METHOD_TYPE = &#x27;method&#x27;,
    EVENT_TYPE = &#x27;event&#x27;,
    PROPERTY_TYPE = &#x27;property&#x27;,
    COLLECTION_TYPE = &#x27;collection&#x27;,
    internalTypes = [&#x27;property&#x27;, &#x27;collection&#x27;, &#x27;method&#x27;, &#x27;event&#x27;],
    defaultTypes = [&#x27;boolean&#x27;, &#x27;string&#x27;, &#x27;number&#x27;, &#x27;object&#x27;, &#x27;function&#x27;, &#x27;array&#x27;],
    store = {
        metadef: {},
        catalog: {},
        inheritance: {},
        inheritanceTree: {},
        model: {},
        states: {},
        type: {},
        implementation: {}
    };


/* Private methods */


/*
 * Create the inheritance tree.
 * @method createInheritanceTree
 * @private
 */
function createInheritanceTree() {
    var id = null,
        ancestorId = null,
        i = 0,
        nbParents = 0;

    function _getAncestors(id, ancestorId) {
        var i = 0,
            nbParents = 0;

        if (store.inheritance[ancestorId]) {
            nbParents = store.inheritance[ancestorId].length;
            if (nbParents) {
                store.inheritanceTree[id] = store.inheritanceTree[id].concat(store.inheritance[ancestorId]);
                for (i = 0; i &lt; nbParents; i++) {
                    _getAncestors(id, store.inheritance[ancestorId][i]);
                }
            }
        }
    }

    for (id in store.inheritance) {

        nbParents = store.inheritance[id].length;
        if (nbParents) {
            store.inheritanceTree[id] = store.inheritance[id];
        }
        for (i = 0; i &lt; nbParents; i++) {
            ancestorId = store.inheritance[id][i];

            _getAncestors(id, ancestorId);
        }
    }
}


/*
 * Extend a schema with the properties of its parent.
 * @method extend
 * @param {type} id id of the schema to extend
 * @return {JSON} object extended with the properties of its parent
 * @private
 */
function extend(id) {
    var sonExtend = {},
        son = store.catalog[id],
        ancestors = store.inheritanceTree[id],
        length = 0,
        i = 0,
        ancestor = null,
        prop = &#x27;&#x27;;

    if (ancestors) {
        length = ancestors.length;
        ancestors.reverse();
    }
    for (i = 0; i &lt; length; i++) {
        ancestor = store.catalog[ancestors[i]];
        for (prop in ancestor) {
            if (prop.indexOf(&#x27;_&#x27;) !== 0) {
                sonExtend[prop] = ancestor[prop];
            }
        }
    }
    for (prop in son) {
        sonExtend[prop] = son[prop];
    }
    return sonExtend;
}


/*
 * Add the models.
 * @method createModel
 * @private
 */
function createModel() {
    var id = &#x27;&#x27;;
    for (id in store.catalog) {
        store.model[id] = extend(id);
    }
}


/*
 * Test if all the schema are compliants with their schemas.
 * @method checkImplementation
 * @private
 */
function checkImplementation() {
    var id = &#x27;&#x27;,
        classDef = null,
        classImp = &#x27;&#x27;;

    for (id in store.model) {
        classDef = store.model[id];
        if (classDef &amp;&amp; typeof classDef[SCHEMA] !== &#x27;undefined&#x27;) {
            classImp = store.model[classDef[SCHEMA]];
            if (classImp) {
                checkImp(classDef, classImp);
                store.implementation[classDef[ID]] = classImp[ID];
            } else {
                $log.missingImplementation(classDef[SCHEMA], classDef[ID]);
            }
        }
    }
}


/*
 * Test if a schema is compliant with its schema.
 * @method checkStates
 * @private
 */
function checkStates() {
    var id = &#x27;&#x27;,
        classDef = null,
        type = &#x27;&#x27;,
        states = [],
        attribute = &#x27;&#x27;;

    for (id in store.model) {
        states = [];
        classDef = store.model[id];
        if (classDef &amp;&amp; typeof classDef[SCHEMA] === &#x27;undefined&#x27;) {
            for (attribute in classDef) {
                type = classDef[attribute];
                if (attribute.indexOf(&#x27;_&#x27;) !== 0 &amp;&amp; internalTypes.indexOf(type) !== -1) {
                    states.push(attribute);
                }
            }
        }
        store.states[id] = states;
    }
}


/*
 * Test if a schema is compliant with its schema.
 * @method checkImp
 * @param {JSON} classDef schema to test 
 * @param {JSON} classImp schema to validate
 * @private
 */
function checkImp(classDef, classImp) {
    var property = &#x27;&#x27;,
        value = null;
    for (property in classImp) {
        if (property !== ID &amp;&amp;
            property !== NAME &amp;&amp;
            property !== INHERITS &amp;&amp;
            property !== SCHEMA &amp;&amp;
            property !== CLASS &amp;&amp;
            property !== CORE) {
            if (typeof classDef[property] !== &#x27;undefined&#x27;) {
                value = classDef[property];
                if (!checkSchema(value, classImp[property])) {
                    $log.invalidTypeImp(property, classDef[ID]);
                }
            } else {
                $log.missingPropertyImp(property, classDef[ID]);
            }
        }
    }
    // check if all properties are there
    for (property in classDef) {
        if (property !== ID &amp;&amp;
            property !== NAME &amp;&amp;
            property !== INHERITS &amp;&amp;
            property !== SCHEMA &amp;&amp;
            property !== CLASS &amp;&amp;
            property !== CORE) {
            if (typeof classImp[property] === &#x27;undefined&#x27;) {
                $log.unknownPropertyImp(property, classDef[ID]);
            }
        }
    }
}


/*
 * Test if a value has the correct type.
 * @method checkSchema
 * @param {Object} value value to test
 * @param {Object} type type to test
 * @return {Boolean} true if the value has the correct type
 * @private
 */
function checkSchema(value, type) {
    var result = true;
    if (hasType(type, &#x27;string&#x27;) &amp;&amp; defaultTypes.indexOf(type) !== -1) {
        result = hasType(value, type);
    } else {
        result = checkCustomSchema(value, type);
    }
    return result;
}


/*
 * Test if a value has correct custom type.
 * @method checkCustomSchema
 * @param {type} value value to test
 * @param {String} typeName type to test
 * @return {Boolean} true if the value has the correct type
 * @private
 */
function checkCustomSchema(value, typeName) {
    var result = true,
        typeDef = store.type[typeName],
        length = 0,
        i = 0;

    if (!hasType(typeDef, &#x27;undefined&#x27;)) {
        if (!hasType(value, &#x27;undefined&#x27;)) {
            if (typeDef.type === &#x27;array&#x27;) {
                length = value.length;
                for (i = 0; i &lt; length; i++) {
                    if (!hasType(typeDef.schema, &#x27;undefined&#x27;)) {
                        result = isValidSchema(value[i], typeDef.schema);
                    } else {
                        result = isValidType(value[i], typeDef.type);
                    }
                    if (result === false) {
                        break;
                    }
                }
            } else {
                if (!hasType(typeDef.schema, &#x27;undefined&#x27;)) {
                    result = isValidSchema(value, typeDef.schema);
                } else {
                    result = isValidType(value, typeDef.type);
                }
            }
        } else {
            result = false;
        }
    } else {
        result = false;
    }

    return result;
}


/*
 * Init the Database stucture.
 * @method initDbStructure
 * @private
 */
function initDbStructure() {
    $db.collection(&#x27;SyrupSchema&#x27;);
    $db.collection(&#x27;SyrupExtendedSchema&#x27;);
    $db.collection(&#x27;SyrupClassInfo&#x27;);
    $db.collection(&#x27;SyrupBehavior&#x27;);
    $db.collection(&#x27;SyrupState&#x27;);
    $db.collection(&#x27;SyrupType&#x27;);
    $db.collection(&#x27;SyrupMessage&#x27;);
    $db.collection(&#x27;SyrupChannel&#x27;);
}


/*
 * Create the Database structure (i.e. SyrupDatabaseCollection).
 * @method createDbStructure
 * @private
 */
function createDbStructure() {
    var modelName = &#x27;&#x27;,
        modelDef = {},
        typeName = &#x27;&#x27;;

    for (modelName in store.catalog) {
        modelDef = store.catalog[modelName];
        $db.SyrupSchema.insert(modelDef);
        if (typeof modelDef[SCHEMA] !== &#x27;undefined&#x27; &amp;&amp;
            typeof $db[modelDef[ID]] === &#x27;undefined&#x27; &amp;&amp;
            modelDef[CLASS] !== false) {
            $db.collection(modelDef[ID]);
        }
    }

    for (modelName in store.model) {
        modelDef = store.model[modelName];
        $db.SyrupExtendedSchema.insert(modelDef);
    }

    for (typeName in store.type) {
        modelDef = store.type[typeName];
        modelDef._id = modelDef.name;
        $db.SyrupType.insert(modelDef);
    }
}


/*
 * Create all the classes of the model.
 * @method createClass
 * @private
 */
function createClass() {
    var modelName = &#x27;&#x27;,
        modelDef = {};

    for (modelName in store.model) {
        modelDef = store.model[modelName];
        if (typeof modelDef[SCHEMA] !== &#x27;undefined&#x27; &amp;&amp; modelDef[CLASS] !== false) {
            $component.create({
                &quot;model&quot;: modelName
            });
        }
    }
}


/*
 * Create all the ClassInfo of the model.
 * @method createClassInfo
 * @private
 */
function createClassInfo() {
    var modelName = &#x27;&#x27;,
        modelDef = {},
        id = &#x27;&#x27;;

    for (modelName in store.model) {
        modelDef = store.model[modelName];
        id = modelDef._id + &#x27;Info&#x27;;

        if (
            typeof modelDef[SCHEMA] !== &#x27;undefined&#x27; &amp;&amp;
            modelDef[CLASS] !== false
            ) {
            if (!$component.get(id)) {
                $db.SyrupClassInfo.insert({
                    &quot;_id&quot;: id,
                    &quot;metamodel&quot;: store.model[modelDef[SCHEMA]],
                    &quot;model&quot;: modelDef
                });
            } else {
                $db.SyrupClassInfo.update({
                    &quot;_id&quot;: id
                }, {
                        &quot;_id&quot;: id,
                        &quot;metamodel&quot;: store.model[modelDef[SCHEMA]],
                        &quot;model&quot;: modelDef
                    });
            }
        }
    }
}


/* 
 * Get the real name of the reference object / type.
 * @method getReference
 * @param {String} value
 * @return {String} real name
 * @private
 */
function getReference(value) {
    return value.replace(&#x27;@&#x27;, &#x27;&#x27;);
}


/*
 * Is the value a custom type.
 * @method isCustomType
 * @param {String} value
 * @return {Boolean}
 * @private
 */
function isCustomType(value) {
    var result = hasType(value, &#x27;string&#x27;) &amp;&amp;
        defaultTypes.indexOf(value) === -1 &amp;&amp;
        !isReference(value);

    return result;
}


/*
 * Is the value a reference.
 * @method isReference
 * @param {String} value
 * @return {Boolean}
 * @private
 */
function isReference(value) {
    return value.indexOf(&#x27;@&#x27;) !== -1;
}


/*
 * Get the real type of a value.
 * @method getType
 * @param {type} value
 * @return {String} type of the value
 * @private
 */
function getType(value) {
    var type = &#x27;&#x27;;

    if (Array.isArray(value)) {
        type = &#x27;array&#x27;;
    } else {
        type = typeof value;
    }

    return type;
}


/*
 * Get the class name of an object.
 * @method getClassName
 * @param {type} obj object
 * @return {String} the class name of the object
 * @private
 */
function getClassName(obj) {
    return obj.constructor.name;
}


/*
 * Check if the value is a valid enum value.
 * @method isValidEnumValue
 * @param {String} value
 * @param {Array} enumValue
 * @return {Boolean} the class name of the object
 * @private
 */
function isValidEnumValue(value, enumValue) {
    return enumValue.indexOf(value) !== -1;
}


/*
 * Check if a value has the specified type.
 * @param {type} value
 * @param {type} type
 * @returns {Boolean} true is value has type &#x27;type&#x27;
 */
function hasType(value, type) {
    var result = true;

    switch (type) {
        case &#x27;array&#x27;:
            result = Array.isArray(value);
            break;
        default:
            result = (type === typeof value);
            break;
    }

    return result;
}


/*
 * Check if an attribute of the schema has a specific type.
 * @method isCollection
 * @param {String} name
 * @param {String} id component id
 * @param {String} type type to check
 * @return {Boolean} true if the attribute has for type type
 */
function checkType(name, id, type) {
    var result = false,
        componentSchema = store.model[id],
        attributeType = &#x27;&#x27;;

    if (componentSchema &amp;&amp; componentSchema[SCHEMA]) {
        componentSchema = store.model[componentSchema[SCHEMA]];
    }

    if (componentSchema) {
        attributeType = componentSchema[name];
        if (attributeType === type) {
            result = true;
        }
    }

    return result;
}

/*
 * Merge two schemas.
 * @method merge
 * @param {Object} source source schema
 * @param {Object} target target schema
 * @return {Object} merged schema
 */
function merge(source, target) {
    var propName = &#x27;&#x27;,
        result = target;

    for (propName in source) {
        if (source.hasOwnProperty(propName) &amp;&amp; propName.indexOf(&#x27;_&#x27;) !== 0) {
            result[propName] = source[propName];
        }
    }
    return result;
}

/* Public methods */


/*
 * Add a new schema.
 * @method schema
 * @param {JSON} importedSchema schema to add
 */
function schema(importedSchema) {
    var id = importedSchema[ID],
        inherit = importedSchema[INHERITS],
        name = importedSchema[NAME];

    // if no id, it will be the name by default
    if (hasType(id, &#x27;undefined&#x27;)) {
        id = name;
        importedSchema[ID] = name;
    }

    // check if schema is compliant with the meta meta model
    if (isValidObject(importedSchema, store.metadef.schema, false)) {

        if (typeof store.catalog[id] === &#x27;undefined&#x27;) {
            store.catalog[id] = importedSchema;
        } else {
            store.catalog[id] = merge(importedSchema, store.catalog[id]);
        }
        if (inherit) {
            store.inheritance[id] = inherit;
        }
    } else {
        $workflow.stop({
            &quot;error&quot;: true,
            &quot;message&quot;: &quot;the schema &#x27;&quot; + JSON.stringify(importedSchema) + &quot;&#x27; is not valid&quot;
        });
    }
}


/*
 * Add a new type.
 * @method type
 * @param {JSON} importedType type to add
 */
function type(importedType) {
    var name = importedType.name;

    // check if type is compliant with the meta meta model
    if (isValidObject(importedType, store.metadef.type)) {
        if (name) {
            store.type[name] = importedType;
        } else {
            $log.invalidTypeDefinition(importedType);
        }
    } else {
        $workflow.stop({
            &quot;error&quot;: true,
            &quot;message&quot;: &quot;the type &#x27;&quot; + JSON.stringify(importedType) + &quot;&#x27; is not valid&quot;
        });
    }
}


/*
 * Init the metamodel.
 * @method init
 */
function init() {
    clear();
    store.metadef = {
        schema: {
            &quot;_id&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;mandatory&quot;: true
            },
            &quot;_name&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;mandatory&quot;: true
            },
            &quot;_inherit&quot;: {
                &quot;type&quot;: [&quot;string&quot;],
                &quot;mandatory&quot;: false
            },
            &quot;_schema&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;mandatory&quot;: false
            },
            &quot;_class&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;mandatory&quot;: false
            },
            &quot;_core&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;mandatory&quot;: false
            }
        },
        type: {
            &quot;name&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;mandatory&quot;: true
            },
            &quot;type&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;mandatory&quot;: true
            },
            &quot;schema&quot;: {
                &quot;type&quot;: &quot;object&quot;,
                &quot;mandatory&quot;: false
            },
            &quot;value&quot;: {
                &quot;type&quot;: [&quot;string&quot;],
                &quot;mandatory&quot;: false
            },
            &quot;core&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;mandatory&quot;: false
            }
        }

    };
    initDbStructure();
}


/*
 * Remove the data of the metamodel from the memory.
 * @method clear
 */
function clear() {
    store = {
        metadef: {},
        catalog: {},
        inheritance: {},
        inheritanceTree: {},
        model: {},
        states: {},
        type: {},
        implementation: {}
    };
}


/*
 * Create the metamodel.
 * @method create
 */
function create() {
    createInheritanceTree();
    createModel();
    checkImplementation();
    checkStates();
    createDbStructure();
    createClass();
    createClassInfo();
}


/*
 * Check if an attribute of the schema is an event.
 * @method isEvent
 * @param {String} name
 * @param {String} id component id
 * @return {Boolean} true if the attribute is an event
 */
function isEvent(name, id) {
    return checkType(name, id, EVENT_TYPE);
}


/*
 * Check if an attribute of the schema is a property.
 * @method isProperty
 * @param {String} name name of the property
 * @param {String} id component id
 * @return {Boolean} true if the attribute is a property
 */
function isProperty(name, id) {
    return checkType(name, id, PROPERTY_TYPE);
}


/*
 * Check if an attribute of the schema is a collection.
 * @method isCollection
 * @param {String} name name of the collection
 * @param {String} id component id
 * @return {Boolean} true if the attribute is a collection
 */
function isCollection(name, id) {
    return checkType(name, id, COLLECTION_TYPE);
}


/*
 * Check if an attribute of the schema is a method.
 * @method isMethod
 * @param {String} name name of the method
 * @param {String} id component id
 * @return {Boolean} true if the attribute is a method
 */
function isMethod(name, id) {
    return checkType(name, id, METHOD_TYPE);
}


/*
 * Check if the name is a correct state for the component.
 * @method isValidState
 * @param {String} name name of the state
 * @param {String} id component id
 * @return {Boolean} true if the name is a correct state for the component
 */
function isValidState(name, id) {
    var result = false,
        componentSchema = store.model[id],
        state = {};

    if (componentSchema &amp;&amp; componentSchema[SCHEMA]) {
        componentSchema = store.model[componentSchema[SCHEMA]];
    }
    state = store.states[componentSchema[ID]];

    if (Array.isArray(state)) {
        result = state.indexOf(name) !== -1;
    }

    return result;
}


/*
 * Check if a value is compliant with a type.
 * @method isValidType
 * @param {Object} object object to validate
 * @param {String} type type to use for validation
 * @return {Boolean} true if the object is compliant with the type
 */
function isValidType(value, typeName) {
    var result = true;

    function _checkReference(value, typeName) {
        var isValid = true;
        var typeRef = getReference(typeName);
        if (hasType(value, &#x27;string&#x27;)) {
            value = $component.get(value);
        }
        if (getClassName(value) !== typeRef) {
            isValid = false;
            $log.invalidType(value, typeName.replace(&#x27;@&#x27;, &#x27;&#x27;));
        }
        return isValid;
    }

    if (!hasType(typeName, &#x27;undefined&#x27;)) {
        switch (true) {
            case isCustomType(typeName):
                result = checkCustomSchema(value, typeName);
                break;
            case isReference(typeName):
                result = _checkReference(value, typeName);
                break;
            default:
                result = hasType(value, typeName);
                break;
        }
    } else {
        $log.invalidType(value, typeName);
    }

    return result;
}


/*
 * Check if a value is compliant with a type enum.
 * @method isValidEnum
 * @param {String|Object} value value to validate
 * @param {Schema} schema schema to use for validation
 * @return {Boolean} true if the object is compliant with the enum
 */
function isValidEnum(value, schema) {
    var result = true;

    function _isInstanceOf(component, className) {
        var result = false,
            componentClassName = &#x27;&#x27;;

        componentClassName = component.constructor.name;

        if (componentClassName === &#x27;Function&#x27;) {
            componentClassName = component.name;
        }
        result = componentClassName === className;

        return result;
    }

    if (isReference(schema.type)) {
        result = _isInstanceOf($component.get(value), getReference(schema.type)) &amp;&amp; schema.value.indexOf(value) !== -1;
        if (!result) {
            $log.invalidEnumValue(value, schema.type);
        }
    } else {
        result = (hasType(value, schema.type)) &amp;&amp; schema.value.indexOf(value) !== -1;
        if (!result) {
            $log.invalidEnumValue(value, schema.type);
        }
    }

    return result;
}


/*
 * Check if the object is compliant with the schema.
 * Use it to test if a schema is compliant with a schema
 * it is supposed to validate.
 * @method isValidSchema
 * @param {JSON} object
 * @param {JSON} schema
 * @return {Boolean}
 * @private
 */
function isValidSchema(object, schema) {
    var fieldName = &#x27;&#x27;,
        field = null,
        result = true,
        mandatory = true,
        typeSchema = &#x27;&#x27;,
        typeRef = &#x27;&#x27;,
        realType = &#x27;&#x27;,
        length = 0,
        i = 0;

    /*
     * Check if a field is compliant with the type of the reference.
     * @return {Boolean} the field is compliant with the type of the reference
     * @private
     */
    function _isValidReference() {
        var isValid = true,
            enumValue = [];

        typeRef = getReference(typeSchema);
        typeRef = object[typeRef];
        if (isCustomType(typeRef)) {
            if (store.type[typeRef]) {
                if (store.type[typeRef].schema) {
                    isValid = isValidSchema(field, store.type[typeRef].schema);
                } else {
                    // check type
                    isValid = hasType(field, store.type[typeRef].type);

                    // check value
                    enumValue = store.type[typeRef].value;
                    if (enumValue) {
                        isValid = isValidEnumValue(field, enumValue);
                    }
                }
            } else {
                isValid = false;
            }
        } else {
            if (typeRef === &#x27;array&#x27;) {
                isValid = Array.isArray(field);
            } else {
                if (isReference(typeRef)) {
                    isValid = hasType(field, &#x27;object&#x27;);
                } else {
                    isValid = hasType(field, typeRef);
                }
            }
        }
        if (!isValid) {
            $log.invalidPropertyType(field, typeRef, field);
        }
        return isValid;
    }

    /*
     * Check if a field is compliant with a type.
     * @return {Boolean} the field is compliant with the type
     * @private
     */
    function _isValidType() {
        var isValid = true;

        realType = getType(typeSchema);
        switch (realType) {
            case &#x27;string&#x27;:
                if (isCustomType(realType)) {
                    isValid = isValidSchema(field, typeSchema);
                } else {
                    if (!hasType(field, typeSchema)) {
                        $log.invalidPropertyType(fieldName, typeSchema, field);
                        isValid = false;
                        break;
                    }
                }
                break;
            case &#x27;array&#x27;:
                length = field.length;
                for (i = 0; i &lt; length; i++) {
                    if (isCustomType(typeSchema[0])) {
                        isValid = isValidSchema(field[i], store.type[typeSchema[0]].schema);
                    } else {
                        if (!hasType(field[i], typeSchema[0])) {
                            $log.invalidPropertyType(field[i], typeSchema[0], field[i]);
                            isValid = false;
                            break;
                        }
                    }
                }
                break;
            default:
                break;
        }
        return isValid;
    }

    // type
    for (fieldName in object) {
        field = object[fieldName];

        if (hasType(schema[fieldName], &#x27;undefined&#x27;)) {
            $log.unknownProperty(fieldName, schema);
            return false;
        } else {
            typeSchema = schema[fieldName].type;
        }

        switch (true) {
            case isReference(typeSchema):
                result = _isValidReference();
                break;
            default:
                result = _isValidType();
                break;
        }
    }

    // mandatory
    for (fieldName in schema) {
        field = schema[fieldName];
        mandatory = field.mandatory;
        if (mandatory === true &amp;&amp; hasType(object[fieldName], &#x27;undefined&#x27;)) {
            $log.missingProperty(fieldName);
            result = false;
            break;
        }
    }

    return result;
}


/*
 * Check if the object is compliant with the schema.
 * Use it to test if the constructor of an object is compliant
 * with the definition of the class.
 * @method isValidObject
 * @param {Object} object object to validate
 * @param {Object} schema schema that validates the object
 * @param {Boolean} strict true if validation is strict
 * @param {Boolean} cleanRef true if we remove the reference to the object
 * @return {Boolean} true is the object is compliant with the schema
 */
function isValidObject(object, schema, strict, cleanRef) {
    var fieldName = &#x27;&#x27;,
        field = null,
        result = true,
        mandatory = true,
        typeSchema = &#x27;&#x27;,
        typeRef = &#x27;&#x27;,
        realType = &#x27;&#x27;,
        length = 0,
        i = 0;

    if (hasType(strict, &#x27;undefined&#x27;)) {
        strict = true;
    }

    if (hasType(cleanRef, &#x27;undefined&#x27;)) {
        strict = false;
    }

    /*
     * Check if a field is compliant with a custom type.
     * @return {Boolean} the field is compliant with the custom type
     * @private
     */
    function _isValidCustomType(field, typeSchema) {
        var isValid = true,
            realType = &#x27;&#x27;;

        realType = store.type[typeSchema];
        if (realType) {
            switch (true) {
                case !hasType(realType.schema, &#x27;undefined&#x27;):
                    isValid = isValidObject(field, realType.schema);
                    break;
                case !hasType(realType.value, &#x27;undefined&#x27;):
                    isValid = isValidEnum(field, realType);
                    break;
                default:
                    isValid = isValidType(field, realType.type);
                    break;
            }
        } else {
            isValid = false;
        }
        return isValid;
    }

    /*
     * Check if a field is compliant with the type of the reference.
     * @return {Boolean} the field is compliant with the type of the reference
     * @private
     */
    function _isValidReference(field, typeSchema) {
        var isValid = true,
            comp = null,
            isComponent = false;

        typeRef = getReference(typeSchema);
        if (field &amp;&amp; field.id) {
            comp = field;
            isComponent = true;
        } else {
            comp = $component.get(field);
        }

        if (!hasType(comp, &#x27;undefined&#x27;)) {
            if (getClassName(comp) !== typeRef) {
                isValid = false;
                $log.invalidType(field, typeRef);
            } else {
                if (isComponent &amp;&amp; cleanRef) {
                    object[fieldName] = comp.id(); // store the id instead the full object 
                }
            }
        } else {
            // check for default value of an object ({} or null)
            switch (true) {
                case (hasType(field, &#x27;object&#x27;) &amp;&amp; field !== null &amp;&amp; Object.keys(field).length &gt; 0):
                case hasType(field, &#x27;string&#x27;):
                    $log.canNotYetValidate(field, typeRef);
                    break;
                default:
                    break;
            }
        }
        return isValid;
    }

    /*
     * Check if a field is compliant with a type.
     * @return {Boolean} the field is compliant with the type
     * @private
     */
    function _isValidType(field, typeSchema) {
        var isValid = true,
            typeArray = &#x27;&#x27;;

        realType = getType(typeSchema);
        switch (realType) {
            case &#x27;string&#x27;:
                if (isCustomType(realType)) {
                    isValid = isValidObject(field, typeSchema);
                } else {
                    if (typeSchema === &#x27;array&#x27;) {
                        if (getType(field) !== &#x27;array&#x27;) {
                            $log.invalidPropertyType(fieldName, typeSchema, field);
                            isValid = false;
                            break;
                        }
                    } else {
                        if (getType(field) !== typeSchema) {
                            $log.invalidPropertyType(fieldName, typeSchema, field);
                            isValid = false;
                            break;
                        }
                    }
                }
                break;
            case &#x27;array&#x27;:
                if (Array.isArray(field)) {
                    length = field.length;
                    typeArray = typeSchema[0];
                    for (i = 0; i &lt; length; i++) {
                        if (isCustomType(typeArray)) {
                            isValid = isValidObject(field[i], store.type[typeArray].schema);
                        } else {
                            if (!isReference(typeArray)) {
                                if (getType(field[i]) !== typeArray) {
                                    $log.invalidPropertyType(field[i], typeArray, field[i]);
                                    isValid = false;
                                    break;
                                }
                            } else {
                                if (getType(field[i]) === &#x27;string&#x27;) {
                                    // Case of an import of a system
                                    if (getClassName($component.get(field[i])) !== getReference(typeArray)) {
                                        $log.invalidClassName(JSON.stringify(field[i]), getReference(typeArray), getClassName(field[i]));
                                        isValid = false;
                                        break;
                                    }
                                } else {
                                    if (getClassName(field[i]) !== getReference(typeArray)) {
                                        $log.invalidClassName(JSON.stringify(field[i]), getReference(typeArray), getClassName(field[i]));
                                        isValid = false;
                                        break;
                                    } else {
                                        if (cleanRef) {
                                            field[i] = field[i].id(); // store the id instead the full object
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    isValid = false;
                    $log.invalidType(field, &#x27;array&#x27;);
                }
                break;
            default:
                isValid = false;
                $log.unknownType(field);
                break;
        }
        return isValid;
    }


    // type
    for (fieldName in object) {
        field = object[fieldName];

        if (!hasType(schema[fieldName], &#x27;undefined&#x27;) || fieldName === &#x27;_core&#x27;) {
            
            // case of _core
            if (fieldName !== &#x27;_core&#x27;) {
                typeSchema = schema[fieldName].type;
            } else {
                typeSchema = &#x27;boolean&#x27;;
            }

            // cas of _id
            if (fieldName === &#x27;_id&#x27;) {
                typeSchema = &#x27;string&#x27;;
            }

        } else {
            if (strict) {
                $log.unknownProperty(fieldName, schema);
                return false;
            } else {
                continue;
            }
        }

        switch (true) {
            case isCustomType(typeSchema):
                result = _isValidCustomType(field, typeSchema);
                break;
            case isReference(typeSchema):
                result = _isValidReference(field, typeSchema);
                break;
            default:
                result = _isValidType(field, typeSchema);
                break;
        }
    }

    // mandatory
    for (fieldName in schema) {
        field = schema[fieldName];
        mandatory = field.mandatory;
        if (hasType(object[fieldName], &#x27;undefined&#x27;)) {
            if (mandatory === true) {
                $log.missingProperty(fieldName);
                result = false;
            }
        }
    }

    return result;
}


/*
 * Prepare the object in order to be compliant with the schema.
 * @method prepareObject
 * @param {Object} object object to prepate
 * @param {Object} schema schema that validates the object
 */
function prepareObject(object, schema) {
    var fieldName = &#x27;&#x27;,
        field = null,
        mandatory = true,
        defaultValue = &#x27;&#x27;;

    // mandatory &amp; default value
    for (fieldName in schema) {
        field = schema[fieldName];
        mandatory = field.mandatory;
        defaultValue = field.default;
        if (hasType(object[fieldName], &#x27;undefined&#x27;)) {
            if (mandatory === false &amp;&amp; !hasType(defaultValue, &#x27;undefined&#x27;)) {
                object[fieldName] = defaultValue;
            }
        }
    }
}


/*
 * Get a schema.
 * @method get
 * @param {String} id of the schema
 * @return {Object} the schema
 */
function get(id) {
    var result = null;
    if (store.model[id]) {
        result = store.model[id];
    }
    return result;
}


/*
 * Get the definition of the metamodel.
 * @method getMetaDef
 * @return {Object} the metadefinition of the metamodel
 */
function getMetaDef() {
    var result = store.metadef.schema;
    return result;
}


/*
 * Get parents of a shema if any.
 * @method get
 * @param {String} id id of the schema
 * @return {Array} id id of the parents
 */
function getParents(id) {
    var result = [],
        model = null;

    model = store.model[id];
    if (model) {
        result = model[INHERITS];
    }
    if (!result) {
        result = [];
    }

    return result;
}

/*
 * Check if a class inherits from another one
 * @method inheritFrom
 * @param {String} name name of the class
 * @param {String} parentName name of the parent
 * @return {Boolean} true if the component inherit from the specific class name
 */
function inheritFrom(name, parentName) {
    var result = false,
        parents = [],
        i = 0,
        length = 0;
        
    /*
     * 
     * Check if a class inherits from another one
     * @method _searchParent
     * @param {String} className name of the class
     * @param {String} ancestorName of the parent
     * @returns {Boolean} true if the component inherit from the specific class name
     * @private
     */
    function _searchParent(className, ancestorName) {
        var isAncestor = false,
            parents = [],
            i = 0,
            length = 0;

        parents = getParents(className);
        if (parents.length !== 0) {
            if (parents.indexOf(ancestorName) !== -1) {
                isAncestor = true;
            } else {
                for (i = 0; i &lt; length; i++) {
                    isAncestor = _searchParent(parents[i], ancestorName);
                    if (isAncestor) {
                        break;
                    }
                }
            }
        }
        return isAncestor;
    }

    if (name !== parentName) {
        parents = getParents(name);
        length = parents.length;

        if (parents.length !== 0) {
            if (parents.indexOf(parentName) !== -1) {
                result = true;
            } else {
                for (i = 0; i &lt; length; i++) {
                    result = _searchParent(parents[i], parentName);
                    if (result) {
                        break;
                    }
                }
            }
        }
    } else {
        result = true;
    }

    return result;
}


/* exports */


/**
 * This module manages syrup metamodel. &lt;br&gt;
 * syrup metamodel loads schemas and types, analyzes them and creates the component classes and related SyrupDatabaseCollections.
 * 
 * @module syrup
 * @submodule syrup-metamodel
 * @requires syrup-db
 * @requires syrup-log
 * @requires syrup-component
 * @requires syrup-workflow
 * @class syrup-metamodel
 * @static
 */


/**
 * Init the metamodel.
 * @method init
 */
exports.init = init;


/**
 * Remove the data of the metamodel from the memory.
 * @method clear
 */
exports.clear = clear;


/**
 * Add a new schema.
 * @method schema
 * @param {JSON} importedSchema a schema to add
 */
exports.schema = schema;


/**
 * Add a new type.
 * @method type
 * @param {JSON} importedType type to add
 */
exports.type = type;


/**
 * Create the metamodel.
 * @method create
 */
exports.create = create;


/**
 * Get a schema.
 * @method get
 * @param {String} id id of the schema
 * @return {Object} the schema
 */
exports.get = get;


/**
 * Get the definition of the metamodel.
 * @method getMetaDef
 * @return {Object} the metadefinition of the metamodel
 */
exports.getMetaDef = getMetaDef;


/**
 * Get parents of a shema if any.
 * @method getParents
 * @param {String} id id of the schema
 * @return {Array} id id of the parents
 */
exports.getParents = getParents;


/**
 * Check if a class inherits from another one
 * @method inheritFrom
 * @param {String} name name of the class
 * @param {String} parentName name of the parent
 * @return {Boolean} true if the component inherit from the specific class name
 */
exports.inheritFrom = inheritFrom;


/**
 * Check if the object is compliant with the schema.
 * Use it to test if the constructor of an object is compliant
 * with the definition of the class.
 * @method isValidObject
 * @param {Object} object object to validate
 * @param {Object} schema schema that validates the object
 * @param {Boolean} strict true if validation is strict
 * @param {Boolean} cleanRef true if we remove the reference to the object
 * @return {Boolean} true is the object is compliant with the schema
 */
exports.isValidObject = isValidObject;


/**
 * Prepare the object in order to be compliant with the schema.
 * @method prepareObject
 * @param {Object} object object to prepare
 * @param {Object} schema schema that validates the object
 */
exports.prepareObject = prepareObject;


/**
 * Check if a value is compliant with a type.
 * @method isValidType
 * @param {Object} object object to validate
 * @param {String} type type to use for validation
 * @return {Boolean} true if the object is compliant with the type
 */
exports.isValidType = isValidType;


/**
 * Check if a value is compliant with a type enum.
 * @method isValidEnum
 * @param {String|Object} value value to validate
 * @param {Schema} schema schema to use for validation
 * @return {Boolean} true if the object is compliant with the enum
 */
exports.isValidEnum = isValidEnum;


/**
 * Check if the name is a correct state for the component.
 * @method isValidState
 * @param {String} name name of the state
 * @param {String} id component id
 * @return {Boolean} true if the name is a correct state for the component
 */
exports.isValidState = isValidState;


/**
 * Check if an attribute of the schema is an event.
 * @method isEvent
 * @param {String} name name of the attribute
 * @param {String} id component id
 * @return {Boolean} true if the attribute is an event
 */
exports.isEvent = isEvent;


/**
 * Check if an attribute of the schema is a property.
 * @method isProperty
 * @param {String} name name of the property
 * @param {String} id component id
 * @return {Boolean} true if the attribute is a property
 */
exports.isProperty = isProperty;


/**
 * Check if an attribute of the schema is a collection.
 * @method isCollection
 * @param {String} name name of the collection
 * @param {String} id component id
 * @return {Boolean} true if the attribute is a collection
 */
exports.isCollection = isCollection;


/**
 * Check if an attribute of the schema is a method.
 * @method isMethod
 * @param {String} name name of the method
 * @param {String} id component id
 * @return {Boolean} true if the attribute is a method
 */
exports.isMethod = isMethod;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
