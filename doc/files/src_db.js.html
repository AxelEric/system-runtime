<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/db.js - monoco</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
            monoco
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.2.2</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/channel", "classes/monoco", "classes/monoco-behavior", "classes/monoco-component", "classes/monoco-db", "classes/monoco-helper", "classes/monoco-log", "classes/monoco-metamodel", "classes/monoco-state", "classes/monoco-system", "classes/monoco-workflow", "classes/MonocoDatabaseCollection", "classes/MonocoError", "modules/channel", "modules/monoco", "modules/monoco-behavior", "modules/monoco-component", "modules/monoco-db", "modules/monoco-helper", "modules/monoco-log", "modules/monoco-metamodel", "modules/monoco-state", "modules/monoco-system", "modules/monoco-workflow"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
            
                <li><a href="../classes/channel.html">channel</a></li>
            
                <li><a href="../classes/monoco.html">monoco</a></li>
            
                <li><a href="../classes/monoco-behavior.html">monoco-behavior</a></li>
            
                <li><a href="../classes/monoco-component.html">monoco-component</a></li>
            
                <li><a href="../classes/monoco-db.html">monoco-db</a></li>
            
                <li><a href="../classes/monoco-helper.html">monoco-helper</a></li>
            
                <li><a href="../classes/monoco-log.html">monoco-log</a></li>
            
                <li><a href="../classes/monoco-metamodel.html">monoco-metamodel</a></li>
            
                <li><a href="../classes/monoco-state.html">monoco-state</a></li>
            
                <li><a href="../classes/monoco-system.html">monoco-system</a></li>
            
                <li><a href="../classes/monoco-workflow.html">monoco-workflow</a></li>
            
                <li><a href="../classes/MonocoDatabaseCollection.html">MonocoDatabaseCollection</a></li>
            
                <li><a href="../classes/MonocoError.html">MonocoError</a></li>
            
        </ul>
    </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>src/db.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/* 
 * monoco
 * A Model and a NoSQL Database for Components
 * http://monoco.io/
 * @ecarriou
 *
 * Copyright (C) 2015 - Erwan Carriou
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/**
 * This module manages Monoco Database. &lt;br&gt;
 * Monoco Database is a micro NoSQL Database that contains: &lt;br&gt;
 * - collections to store documents (schemas, types, components, ...) and &lt;br&gt;
 * - APIs to import or export documents. &lt;br&gt;
 * 
 * Monoco Database is closely linked to Monoco Metamodel and Monoco Component because: &lt;br&gt;
 * - all operations done by Monoco Database must be compliant with the model before being finished, &lt;br&gt;
 * - insert operation automatically creates a component and &lt;br&gt;
 * - remove operation automatically destroy a component.
 *  
 * @module monoco
 * @submodule monoco-db
 * @requires monoco-component
 * @requires monoco-helper
 * @requires monoco-log
 * @class monoco-db
 * @static
 */

&#x27;use strict&#x27;;

var $component = require(&#x27;./component.js&#x27;);
var $metamodel = require(&#x27;./metamodel.js&#x27;);
var $helper = require(&#x27;./helper.js&#x27;);
var $log = require(&#x27;./log.js&#x27;);


/* Private properties */


var store = {},
collections = [],
internalDB = [
    &#x27;Monoco&#x27;,
    &#x27;MonocoSchema&#x27;,
    &#x27;MonocoExtendedSchema&#x27;,
    &#x27;MonocoBehavior&#x27;,
    &#x27;MonocoState&#x27;,
    &#x27;MonocoType&#x27;,
    &#x27;MonocoMetamodel&#x27;,
    &#x27;MonocoDatabase&#x27;,
    &#x27;MonocoSystem&#x27;,
    &#x27;MonocoClassInfo&#x27;,
    &#x27;MonocoMessage&#x27;,
    &#x27;MonocoChannel&#x27;
];


/* Private methods */


/*
 * Test if an object contains another one.
 * @method contains
 * @param {Object} source source object 
 * @param {Object} target otarget bject 
 * @return {Boolean} true if the source object contains the target object
 * @private
 */
function contains(source, target) {
    var result = true,
    property = {};

    for (property in source) {
        if (typeof target[property] === &#x27;undefined&#x27; || target[property] !== source[property]) {
            result = false;
            break;
        }
    }
    return result;
}


/** 
 * A collection of documents managed by Monoco. &lt;br&gt;
 * Internal collections manage core objects of Monoco (schema, type, ...). &lt;br&gt;
 * Public collections manage components of the same class. &lt;br&gt;
 * 
 * @class MonocoDatabaseCollection
 * @constructor
 * @param {String} name name of the new collection
 */
var MonocoDatabaseCollection = function (name) {
    if ($metamodel.get(name) ||Â internalDB.indexOf(name) !== -1) {
        store[name] = {};
        this.name = name;
        if (internalDB.indexOf(name) === -1) {
            collections.push(name);
        }
    } else {
        $log.invalidCollectionName(name);
    }
};


/**
 * Find a document into the collection.
 * @method find
 * @param {Object|Array} query
 * @return {Array} Array of documents that map the query
 * 
 * @example 
 * $db.Person.find({&quot;name&quot;: &quot;laure&quot;}); &lt;br&gt;
 * $db.Person.find({&quot;name&quot;: &quot;laure&quot;, &quot;age&quot; : 24}); &lt;br&gt;
 * $db.Person.find([{&quot;name&quot;: &quot;rene&quot;}, {&quot;name&quot;: &quot;robert&quot;}]);
 */
MonocoDatabaseCollection.prototype.find = function (query) {
    var result = [],
    id = &#x27;&#x27;,
    object = {};

    query = query || null;

    if (query &amp;&amp; Object.keys(query).length) {
        if (Array.isArray(query)) {
            query.forEach(function multi_search(criteria) {
                for (id in store[this.name]) {
                    object = store[this.name][id];
                    if (contains(criteria, object)) {
                        result.push(object);
                    }
                }
            }.bind(this));
        } else {
            for (id in store[this.name]) {
                object = store[this.name][id];
                if (contains(query, object)) {
                    result.push(object);
                }
            }
        }
    } else {
        for (id in store[this.name]) {
            object = store[this.name][id];
            result.push(object);
        }
    }

    return result;
};


/**
 * Insert an new document into the collection. &lt;br&gt;
 * Before inserting the document, Monoco checks that the document is compliant
 * with its class definition. &lt;br&gt; 
 * Then, after inserting it, we create the component.
 * @method insert
 * @param {Object|Array} document a new object to add
 * @return {Array} array of id created
 * 
 * @example 
 * $db.Person.insert({&lt;br&gt;
 *      &quot;name&quot;: &quot;bob&quot;, &lt;br&gt;
 *      &quot;firstName&quot;: &quot;Saint-Clar&quot;, &lt;br&gt;
 *      &quot;age&quot;: 43 &lt;br&gt;
 * }); &lt;br&gt;
 */
MonocoDatabaseCollection.prototype.insert = function (document) {
    var doc = [],
    Component = null,
    result = [];

    if (Array.isArray(document)) {
        doc = document;
    } else {
        doc.push(document);
    }

    doc.forEach(function multi_insert(obj) {
        var component = null;
        if (this.name === &#x27;MonocoSchema&#x27; || this.name === &#x27;MonocoType&#x27; || this.name === &#x27;MonocoExtendedSchema&#x27; || $metamodel.isValidObject(obj, $metamodel.get(this.name))) {
            if (typeof obj._id === &#x27;undefined&#x27;) {
                obj._id = $helper.generateId();
            }

            store[this.name][obj._id] = obj;
            Component = $component.get(this.name);
            if (Component) {
                component = new Component(obj);
                result.push(component.id());
            } else {
                if ($helper.isMonoco() &amp;&amp; $helper.getMonoco().require(&#x27;db&#x27;)) {
                    $helper.getMonoco().require(&#x27;db&#x27;).insert(this.name, obj);
                }
            }
            
            if (this.name === &#x27;MonocoMessage&#x27;) {
                if ($helper.isMonoco() &amp;&amp; $helper.getMonoco().require(&#x27;channel&#x27;)) {
                    $helper.getMonoco().require(&#x27;channel&#x27;)[obj.event](obj.data);
                }
            }
            
        } else {
            $log.invalidDocumentOnDbInsert(obj, this.name);
        }
    }.bind(this));

    return result;
};


/**
 * Update documents into a collection.
 * @method update
 * @param {Object|Array} query query to find the documents to update
 * @param {Object} update update to make
 * @param {Object} options 
 * {Boolean} upsert true if we create a document when no document is found by the query
 * @return {Number} Number of documents updated
 * 
 * @example 
 * $db.Cars.update({&quot;code&quot;: &quot;AZD-71&quot;}, {&quot;price&quot;: &quot;10000$&quot;}); &lt;br&gt;
 * $db.Cars.update([{&quot;code&quot;: &quot;AZD-71&quot;}, {&quot;code&quot;: &quot;AZD-65&quot;}], {&quot;price&quot;: &quot;10000$&quot;}); &lt;br&gt;
 * $db.Cars.update({&quot;code&quot;: &quot;AZD-71&quot;}, {&quot;price&quot;: &quot;10000$&quot;}, {&quot;upsert&quot;: true}); &lt;br&gt;
 */
MonocoDatabaseCollection.prototype.update = function (query, update, options) {
    var docs = this.find(query),
    updated = 0,
    i = 0,
    length = docs.length,
    attributeName = &#x27;&#x27;,
    schema = $metamodel.get(this.name);

    options = options || {};
    if (typeof options.upsert === &#x27;undefined&#x27;) {
        options.upsert = options.upsert || false;
    }

    if (update) {

        // upsert case
        if (length === 0 &amp;&amp; options.upsert) {
            if (query._id) {
                update._id = query._id;
            }
            this.insert(update);
            updated = updated + 1;
        }

        for (i = 0; i &lt; length; i++) {
            for (attributeName in update) {
                if (typeof docs[i][attributeName] !== &#x27;undefined&#x27;) {
                    if (schema[attributeName] &amp;&amp; schema[attributeName].type &amp;&amp; $metamodel.isValidType(update[attributeName], schema[attributeName].type)) {
                        docs[i][attributeName] = update[attributeName];
                        updated = updated + 1;
                        if ($helper.isMonoco()) {
                            $helper.getMonoco().require(&#x27;db&#x27;).update(this.name, docs[i]._id, attributeName, update[attributeName]);
                        }
                    } else {
                        $log.invalidPropertyTypeOnDbUpdate(this.name, docs[i]._id, attributeName, update[attributeName], schema[attributeName]);
                    }
                }
            }
        }
    }

    return updated;
};


/**
 * Remove a document from the colllection. &lt;br&gt;
 * When a document is removed, the component is destroyed.
 * @method remove
 * @param {Object|Array} query query to find the documents to remove
 * @return {Number} number of documents removed
 * 
 * @example 
 * $db.Cars.remove({&quot;code&quot;: &quot;AZD-71&quot;}); &lt;br&gt;
 * $db.Cars.remove([{&quot;code&quot;: &quot;AZD-71&quot;}, {&quot;code&quot;: &quot;AZD-65&quot;}]); &lt;br&gt;
 */
MonocoDatabaseCollection.prototype.remove = function (query) {
    var result = 0,
    id = &#x27;&#x27;,
    component = null,
    object = {};

    query = query || null;

    if (query &amp;&amp; Object.keys(query).length) {

        if (Array.isArray(query)) {
            query.forEach(function multi_remove(criteria) {
                for (id in store[this.name]) {
                    object = store[this.name][id];

                    if (contains(criteria, object)) {
                        delete store[this.name][id];
                        component = $component.get(id);
                        if (component) {
                            component.destroy();
                        }
                        if ($helper.isMonoco()) {
                            $helper.getMonoco().require(&#x27;db&#x27;).remove(this.name, id);
                        }
                        result++;
                    }
                }
            }.bind(this));
        } else {
            for (id in store[this.name]) {
                object = store[this.name][id];

                if (contains(query, object)) {
                    delete store[this.name][id];
                    component = $component.get(id);
                    if (component) {
                        component.destroy();
                    }
                    if ($helper.isMonoco()) {
                        $helper.getMonoco().require(&#x27;db&#x27;).remove(this.name, id);
                    }
                    result++;
                }
            }
        }
    } else {
        for (id in store[this.name]) {
            delete store[this.name][id];
            component = $component.get(id);
            if (component) {
                component.destroy();
            }
            if ($helper.isMonoco() &amp;&amp; $helper.getMonoco().require(&#x27;db&#x27;)) {
                $helper.getMonoco().require(&#x27;db&#x27;).remove(this.name, id);
            }
            result++;
        }
    }

    return result;
};


/**
 * Count the number of documents in the collection.
 * @method count
 * @return {Number} number of documents in the collection
 */
MonocoDatabaseCollection.prototype.count = function () {
    var result = 0,
    objectId = &#x27;&#x27;;
    for (objectId in store[this.name]) {
        result++;
    }
    return result;
};


/* Public methods */


/*
 * Create a new {{#crossLink &quot;MonocoDatabaseCollection&quot;}}{{/crossLink}}.
 * @method collection
 * @param {String} name of the collection
 */
function collection(name) {
    exports[name] = new MonocoDatabaseCollection(name);
}


/*
 * Dump the database.
 * @method dump
 * @return {Object} the dump of the database. The dump is an object that contains: &lt;br&gt;
 * {Object} schemas the schemas store in the database &lt;br&gt;
 * {Object} types the types store in the database &lt;br&gt;
 * {Object} behaviors the behaviors store in the database &lt;br&gt;
 * {Object} components the components store in the database
 */
function dump() {
    var dbDump = {},
    collectionName = &#x27;&#x27;,
    behaviorId = &#x27;&#x27;,
    typeId = &#x27;&#x27;,
    type = null,
    behavior = null,
    schema = null,
    schemaId = &#x27;&#x27;,
    length = 0,
    i = 0;

    // schemas
    dbDump.schemas = {};
    if (exports.MonocoSchema.count()) {
        for (schemaId in store.MonocoSchema) {
            schema = store.MonocoSchema[schemaId];
            if (!schema._core) {
                dbDump.schemas[schemaId] = schema;
            }
        }
    }

    // types
    dbDump.types = {};
    if (exports.MonocoType.count()) {
        for (typeId in store.MonocoType) {
            type = JSON.parse(JSON.stringify(store.MonocoType[typeId]));
            delete type._id;
            if (!type.core) {
                dbDump.types[type.name] = type;
            }
        }
    }

    // behaviors
    dbDump.behaviors = {};
    for (behaviorId in store.MonocoBehavior) {
        behavior = JSON.parse(JSON.stringify(store.MonocoBehavior[behaviorId]));
        if (!behavior.core) {
            dbDump.behaviors[behaviorId] = behavior;
        }
    }

    // components
    dbDump.components = {};
    length = collections.length;
    for (i = 0; i &lt; length; i++) {
        collectionName = collections[i];
        if (exports[collectionName].count()) {
            dbDump.components[collectionName] = store[collectionName];
        }
    }

    return dbDump;
}


/*
 * Import/Export a Monoco System into/from the database
 * @method system
 * @param {JSON} importedSystem a Monoco System to import
 * @return {String} the id of the imported Monoco System or the if of the current Monoco System  
 */
function system(importedSystem) {
    var result = &#x27;&#x27;,
    collectionName = &#x27;&#x27;,
    componentId = &#x27;&#x27;,
    typeName = &#x27;&#x27;,
    schemaName = &#x27;&#x27;,
    behaviorId = &#x27;&#x27;,
    systems = [],
    id = null,
    mastersystem = null,
    behavior = null,
    exportedSystem = {};

    if (importedSystem) { // import

        // add types
        for (typeName in importedSystem.types) {
            $metamodel.type(importedSystem.types[typeName]);
        }

        // add schemas
        for (schemaName in importedSystem.schemas) {
            $metamodel.schema(importedSystem.schemas[schemaName]);
        }

        $metamodel.create();

        //add behaviors
        for (behaviorId in importedSystem.behaviors) {
            exports.MonocoBehavior.insert(importedSystem.behaviors[behaviorId]);
        }

        // add components
        for (collectionName in importedSystem.components) {
            for (componentId in importedSystem.components[collectionName]) {
                exports[collectionName].insert(importedSystem.components[collectionName][componentId]);
            }
        }

        // reset info if already a master system
        systems = exports.MonocoSystem.find({&#x27;master&#x27;: true});
        if (systems.length &amp;&amp; systems[0]._id === importedSystem._id) {
            importedSystem.master = true;
        } else {
            importedSystem.master = false;
        }

        // insert the system in DB
        exports.MonocoSystem.insert(importedSystem);

        result = importedSystem._id;

    } else { // export
        exportedSystem = dump();

        // get id of the master system
        systems = exports.MonocoSystem.find({&#x27;master&#x27;: true});

        if (systems.length) {
            mastersystem = systems[0];
            id = mastersystem._id;
            for (behaviorId in exportedSystem.behaviors) {
                behavior = exportedSystem.behaviors[behaviorId];
                if (behavior.state === &#x27;main&#x27;) {
                    behavior.component = id;
                }
            }

            exportedSystem.name = mastersystem.name;
            exportedSystem.version = mastersystem.version;
            exportedSystem.description = mastersystem.description;
            exportedSystem._id = id;

            result = JSON.stringify(exportedSystem);
        } else {
            $log.masterSystemNotFound();
        }
    }
    return result;
}


/*
 * Export a Monoco sub-system.
 * @method subsystem
 * @param {JSON} params parameters
 * @return {String} a stringified Monoco sub-system
 * 
 * @example
 * $db.subsystem({&quot;schemas&quot;:{&quot;name&quot;:&quot;Person&quot;}}); // filter export on schemas &lt;br&gt;
 * $db.subsystem({&quot;types&quot;:{&quot;name&quot;:&quot;address&quot;}}); // filter export on types &lt;br&gt;
 * $db.subsystem({&quot;behaviors&quot;:{&quot;component&quot;:&quot;laure&quot;}}); // filter export on behaviors &lt;br&gt;
 * $db.subsystem({&quot;components&quot;:{&quot;Person&quot;: {&quot;country&quot;: &quot;France&quot;}}}); // filter export on components &lt;br&gt;
 * $db.subsystem({&quot;schemas&quot;:{&quot;name&quot;:&quot;Person&quot;},&quot;components&quot;:{&quot;Person&quot;: {&quot;country&quot;: &quot;France&quot;}}}); // combine filters
 */
function subsystem(params) {
    var system = {},
    result = [],
    defaultName = &#x27;&#x27;,
    i = 0,
    length = 0,
    schema = null,
    type = null,
    behavior = null,
    component = null,
    className = &#x27;&#x27;;

    // default values
    result = monoco.find(&#x27;MonocoSystem&#x27;, {
        &#x27;master&#x27;: true
    });
    if (result.length) {
        defaultName = result[0].name();
    }

    system.name = params.name || &#x27;sub_&#x27; + defaultName;
    system.version = params.version || &#x27;0.0.1&#x27;;
    system.description = params.description ||Â &#x27;&#x27;;

    system.subsystem = true;

    // schemas
    system.schemas = {};
    if (params.schemas) {
        result = exports.MonocoSchema.find(params.schema);

        length = result.length;
        for (i = 0; i &lt; length; i++) {
            schema = result[i];
            if (!schema._core) {
                system.schemas[schema._id] = schema;
            }
        }
    }

    // types
    system.types = {};
    if (params.types) {
        result = exports.MonocoType.find(params.types);

        length = result.length;
        for (i = 0; i &lt; length; i++) {
            type = result[i];
            if (!type._core) {
                system.types[type._id] = type;
            }
        }
    }

    // behaviors
    system.behaviors = {};
    if (params.behaviors) {
        behavior = exports.MonocoBehavior.find(params.behaviors);

        length = result.length;
        for (i = 0; i &lt; length; i++) {
            behavior = result[i];
            if (!behavior.core) {
                system.behaviors[behavior._id] = behavior;
            }
        }
    }

    // components
    system.components = {};
    if (params.components) {
        for (className in params.components) {
            if (exports[className]) {
                system.components[className] = {};

                result = exports[className].find(params.components[className]);
                length = result.length;
                for (i = 0; i &lt; length; i++) {
                    component = result[i];
                    system.components[className][component._id] = component;
                }
            }
        }
    }

    return JSON.stringify(system);
}


/* exports */


/**
 * This module manages Monoco Database. &lt;br&gt;
 * Monoco Database is a micro NoSQL Database that contains: &lt;br&gt;
 * - collections to store documents (schemas, types, components, ...) and &lt;br&gt;
 * - APIs to import or export documents. &lt;br&gt;
 * 
 * Monoco Database is closely linked to Monoco Metamodel because: &lt;br&gt;
 * - all operations done by Monoco Database must be compliant with the model before being finished, &lt;br&gt;
 * - insert operation automatically creates a component and &lt;br&gt;
 * - remove operation automatically destroy a component.
 *   
 * @module monoco
 * @submodule monoco-db
 * @requires monoco-component
 * @requires monoco-helper
 * @requires monoco-log
 * @class monoco-db
 * @static
 */


/**
 * Create a new {{#crossLink &quot;MonocoDatabaseCollection&quot;}}{{/crossLink}}.
 * @method collection
 * @param {String} name of the collection
 */
exports.collection = collection;


/**
 * Monoco Database store that list all the collections.
 * @property {JSON} store
 */
exports.store = store;


/**
 * Dump the database.
 * @method dump
 * @return {Object} the dump of the database. The dump is an object that contains: &lt;br&gt;
 * {Object} schemas the schemas store in the database &lt;br&gt;
 * {Object} types the types store in the database &lt;br&gt;
 * {Object} behaviors the behaviors store in the database &lt;br&gt;
 * {Object} components the components store in the database
 */
exports.dump = dump;


/**
 * Import/Export a Monoco System into/from the database.
 * @method system
 * @param {JSON} importedSystem a Monoco System to import
 * @return {String} the id of the imported Monoco System or the current Monoco System  
 */
exports.system = system;


/**
 * Export a Monoco sub-system.
 * @method subsystem
 * @param {JSON} params parameters
 * @return {String} a stringified Monoco sub-system
 * 
 * @example
 * $db.subsystem({&quot;schemas&quot;:{&quot;name&quot;:&quot;Person&quot;}}); // filter export on schemas &lt;br&gt;
 * $db.subsystem({&quot;types&quot;:{&quot;name&quot;:&quot;address&quot;}}); // filter export on types &lt;br&gt;
 * $db.subsystem({&quot;behaviors&quot;:{&quot;component&quot;:&quot;laure&quot;}}); // filter export on behaviors &lt;br&gt;
 * $db.subsystem({&quot;components&quot;:{&quot;Person&quot;: {&quot;country&quot;: &quot;France&quot;}}}); // filter export on components &lt;br&gt;
 * $db.subsystem({&quot;schemas&quot;:{&quot;name&quot;:&quot;Person&quot;},&quot;components&quot;:{&quot;Person&quot;: {&quot;country&quot;: &quot;France&quot;}}}); // combine filters
 */
exports.subsystem = subsystem;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
